#!/usr/bin/env python3
"""
Server Init - Iteration 338: Key Management Service Platform
ĞŸĞ»Ğ°Ñ‚Ñ„Ğ¾Ñ€Ğ¼Ğ° ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ ĞºÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ³Ñ€Ğ°Ñ„Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¼Ğ¸ ĞºĞ»ÑÑ‡Ğ°Ğ¼Ğ¸

Ğ¤ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»:
- Key Generation - Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ñ ĞºĞ»ÑÑ‡ĞµĞ¹
- Key Storage - Ğ±ĞµĞ·Ğ¾Ğ¿Ğ°ÑĞ½Ğ¾Ğµ Ñ…Ñ€Ğ°Ğ½ĞµĞ½Ğ¸Ğµ ĞºĞ»ÑÑ‡ĞµĞ¹
- Key Rotation - Ñ€Ğ¾Ñ‚Ğ°Ñ†Ğ¸Ñ ĞºĞ»ÑÑ‡ĞµĞ¹
- Encryption/Decryption - ÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ/Ğ´ĞµÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ
- Digital Signatures - Ñ†Ğ¸Ñ„Ñ€Ğ¾Ğ²Ñ‹Ğµ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞ¸
- Key Versioning - Ğ²ĞµÑ€ÑĞ¸Ğ¾Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºĞ»ÑÑ‡ĞµĞ¹
- Access Control - ĞºĞ¾Ğ½Ñ‚Ñ€Ğ¾Ğ»ÑŒ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°
- HSM Integration - Ğ¸Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ HSM
"""

import asyncio
import random
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Set
from enum import Enum
import uuid
import hashlib
import base64


class KeyType(Enum):
    """Ğ¢Ğ¸Ğ¿ ĞºĞ»ÑÑ‡Ğ°"""
    SYMMETRIC = "symmetric"
    ASYMMETRIC = "asymmetric"
    HMAC = "hmac"


class KeyAlgorithm(Enum):
    """ĞĞ»Ğ³Ğ¾Ñ€Ğ¸Ñ‚Ğ¼ ĞºĞ»ÑÑ‡Ğ°"""
    AES_128 = "aes_128"
    AES_256 = "aes_256"
    RSA_2048 = "rsa_2048"
    RSA_4096 = "rsa_4096"
    ECDSA_P256 = "ecdsa_p256"
    ECDSA_P384 = "ecdsa_p384"
    ED25519 = "ed25519"
    HMAC_SHA256 = "hmac_sha256"
    HMAC_SHA512 = "hmac_sha512"


class KeyState(Enum):
    """Ğ¡Ğ¾ÑÑ‚Ğ¾ÑĞ½Ğ¸Ğµ ĞºĞ»ÑÑ‡Ğ°"""
    PENDING_GENERATION = "pending_generation"
    ENABLED = "enabled"
    DISABLED = "disabled"
    PENDING_DELETION = "pending_deletion"
    DESTROYED = "destroyed"
    PENDING_IMPORT = "pending_import"


class KeyUsage(Enum):
    """Ğ˜ÑĞ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ĞºĞ»ÑÑ‡Ğ°"""
    ENCRYPT_DECRYPT = "encrypt_decrypt"
    SIGN_VERIFY = "sign_verify"
    WRAP_UNWRAP = "wrap_unwrap"
    GENERATE_VERIFY_MAC = "generate_verify_mac"


class KeyOrigin(Enum):
    """ĞŸÑ€Ğ¾Ğ¸ÑÑ…Ğ¾Ğ¶Ğ´ĞµĞ½Ğ¸Ğµ ĞºĞ»ÑÑ‡Ğ°"""
    KMS = "kms"  # Generated by KMS
    EXTERNAL = "external"  # Imported
    HSM = "hsm"  # Generated in HSM


class HSMStatus(Enum):
    """Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ HSM"""
    AVAILABLE = "available"
    UNAVAILABLE = "unavailable"
    DEGRADED = "degraded"


@dataclass
class CryptoKey:
    """ĞšÑ€Ğ¸Ğ¿Ñ‚Ğ¾Ğ³Ñ€Ğ°Ñ„Ğ¸Ñ‡ĞµÑĞºĞ¸Ğ¹ ĞºĞ»ÑÑ‡"""
    key_id: str
    name: str
    
    # Type
    key_type: KeyType = KeyType.SYMMETRIC
    algorithm: KeyAlgorithm = KeyAlgorithm.AES_256
    
    # Key material (simulated - in real system would be protected)
    key_material_hash: str = ""
    public_key_pem: str = ""  # For asymmetric keys
    
    # Usage
    usage: List[KeyUsage] = field(default_factory=list)
    
    # State
    state: KeyState = KeyState.ENABLED
    
    # Origin
    origin: KeyOrigin = KeyOrigin.KMS
    
    # Versioning
    current_version: int = 1
    rotation_period_days: int = 365
    next_rotation: Optional[datetime] = None
    
    # Protection
    is_exportable: bool = False
    hsm_protected: bool = False
    
    # Labels
    labels: Dict[str, str] = field(default_factory=dict)
    description: str = ""
    
    # Access
    owner_id: str = ""
    
    # Statistics
    operations_count: int = 0
    last_used: Optional[datetime] = None
    
    # Timestamps
    created_at: datetime = field(default_factory=datetime.now)
    last_rotated: Optional[datetime] = None


@dataclass
class KeyVersion:
    """Ğ’ĞµÑ€ÑĞ¸Ñ ĞºĞ»ÑÑ‡Ğ°"""
    version_id: str
    key_id: str
    version_number: int
    
    # Key material
    key_material_hash: str = ""
    public_key_pem: str = ""
    
    # State
    state: KeyState = KeyState.ENABLED
    is_primary: bool = True
    
    # Algorithm
    algorithm: KeyAlgorithm = KeyAlgorithm.AES_256
    
    # Stats
    operations_count: int = 0
    
    # Timestamps
    created_at: datetime = field(default_factory=datetime.now)
    destroy_time: Optional[datetime] = None


@dataclass
class KeyRing:
    """Ğ¡Ğ²ÑĞ·ĞºĞ° ĞºĞ»ÑÑ‡ĞµĞ¹"""
    ring_id: str
    name: str
    
    # Location
    location: str = "global"
    
    # Keys
    key_ids: List[str] = field(default_factory=list)
    
    # Labels
    labels: Dict[str, str] = field(default_factory=dict)
    
    # Timestamps
    created_at: datetime = field(default_factory=datetime.now)


@dataclass
class EncryptionRequest:
    """Ğ—Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ½Ğ° ÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ"""
    request_id: str
    
    # Key
    key_id: str = ""
    key_version: int = 0
    
    # Operation
    operation: str = "encrypt"  # encrypt, decrypt
    
    # Data
    plaintext_crc32c: str = ""
    ciphertext_crc32c: str = ""
    
    # Context
    additional_authenticated_data: str = ""
    
    # Result
    success: bool = False
    error_message: str = ""
    
    # Stats
    input_size_bytes: int = 0
    output_size_bytes: int = 0
    processing_time_ms: float = 0.0
    
    # Timestamps
    requested_at: datetime = field(default_factory=datetime.now)


@dataclass
class SignatureRequest:
    """Ğ—Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ½Ğ° Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑÑŒ"""
    request_id: str
    
    # Key
    key_id: str = ""
    key_version: int = 0
    
    # Operation
    operation: str = "sign"  # sign, verify
    
    # Digest
    digest_algorithm: str = "sha256"
    digest_crc32c: str = ""
    
    # Signature
    signature: str = ""
    signature_crc32c: str = ""
    
    # Result
    success: bool = False
    verified: Optional[bool] = None  # For verify operations
    error_message: str = ""
    
    # Timestamps
    requested_at: datetime = field(default_factory=datetime.now)


@dataclass
class KeyPolicy:
    """ĞŸĞ¾Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ° Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ° Ğº ĞºĞ»ÑÑ‡Ñƒ"""
    policy_id: str
    name: str
    
    # Scope
    key_ring_ids: List[str] = field(default_factory=list)
    key_ids: List[str] = field(default_factory=list)
    
    # Permissions
    allowed_operations: List[str] = field(default_factory=list)
    
    # Principals
    principals: List[str] = field(default_factory=list)
    
    # Conditions
    valid_from: Optional[datetime] = None
    valid_until: Optional[datetime] = None
    
    # Status
    is_enabled: bool = True
    
    # Timestamps
    created_at: datetime = field(default_factory=datetime.now)


@dataclass
class HSMCluster:
    """HSM ĞºĞ»Ğ°ÑÑ‚ĞµÑ€"""
    cluster_id: str
    name: str
    
    # Type
    hsm_type: str = "cloud"  # cloud, on-premise, dedicated
    
    # Status
    status: HSMStatus = HSMStatus.AVAILABLE
    
    # HSMs
    hsm_ids: List[str] = field(default_factory=list)
    
    # Keys
    protected_key_ids: List[str] = field(default_factory=list)
    
    # Network
    endpoint: str = ""
    
    # Stats
    operations_count: int = 0
    
    # Timestamps
    created_at: datetime = field(default_factory=datetime.now)


@dataclass
class ImportJob:
    """Ğ—Ğ°Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ½Ğ° Ğ¸Ğ¼Ğ¿Ğ¾Ñ€Ñ‚ ĞºĞ»ÑÑ‡Ğ°"""
    job_id: str
    
    # Target
    key_id: str = ""
    
    # Import material
    import_method: str = "rsa_oaep"  # rsa_oaep, direct
    wrapping_key_id: str = ""
    
    # Status
    status: str = "pending"  # pending, in_progress, completed, failed
    
    # Result
    error_message: str = ""
    
    # Expiration
    expires_at: Optional[datetime] = None
    
    # Timestamps
    created_at: datetime = field(default_factory=datetime.now)
    completed_at: Optional[datetime] = None


@dataclass
class AuditLogEntry:
    """Ğ—Ğ°Ğ¿Ğ¸ÑÑŒ Ğ°ÑƒĞ´Ğ¸Ñ‚Ğ°"""
    log_id: str
    
    # Operation
    operation: str = ""
    
    # Target
    key_id: str = ""
    key_version: int = 0
    
    # Principal
    principal_id: str = ""
    
    # Context
    source_ip: str = ""
    user_agent: str = ""
    
    # Result
    success: bool = True
    error_code: str = ""
    
    # Details
    details: Dict[str, Any] = field(default_factory=dict)
    
    # Timestamp
    timestamp: datetime = field(default_factory=datetime.now)


class KeyManagementService:
    """Ğ¡ĞµÑ€Ğ²Ğ¸Ñ ÑƒĞ¿Ñ€Ğ°Ğ²Ğ»ĞµĞ½Ğ¸Ñ ĞºĞ»ÑÑ‡Ğ°Ğ¼Ğ¸"""
    
    def __init__(self):
        self.keys: Dict[str, CryptoKey] = {}
        self.key_versions: Dict[str, List[KeyVersion]] = {}
        self.key_rings: Dict[str, KeyRing] = {}
        self.policies: Dict[str, KeyPolicy] = {}
        self.hsm_clusters: Dict[str, HSMCluster] = {}
        self.import_jobs: Dict[str, ImportJob] = {}
        self.audit_logs: List[AuditLogEntry] = []
        self.encryption_requests: List[EncryptionRequest] = []
        self.signature_requests: List[SignatureRequest] = []
        
    def _generate_key_material(self, algorithm: KeyAlgorithm) -> str:
        """Ğ¡Ğ¸Ğ¼ÑƒĞ»ÑÑ†Ğ¸Ñ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ ĞºĞ»ÑÑ‡ĞµĞ²Ğ¾Ğ³Ğ¾ Ğ¼Ğ°Ñ‚ĞµÑ€Ğ¸Ğ°Ğ»Ğ°"""
        # In real implementation, this would use cryptographic libraries
        random_data = uuid.uuid4().hex + uuid.uuid4().hex
        return hashlib.sha256(random_data.encode()).hexdigest()
        
    def _generate_public_key(self, algorithm: KeyAlgorithm) -> str:
        """Ğ¡Ğ¸Ğ¼ÑƒĞ»ÑÑ†Ğ¸Ñ Ğ³ĞµĞ½ĞµÑ€Ğ°Ñ†Ğ¸Ğ¸ Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ğ¾Ğ³Ğ¾ ĞºĞ»ÑÑ‡Ğ°"""
        if algorithm in [KeyAlgorithm.RSA_2048, KeyAlgorithm.RSA_4096]:
            return f"-----BEGIN PUBLIC KEY-----\nMIIB...simulated...{algorithm.value}...\n-----END PUBLIC KEY-----"
        elif algorithm in [KeyAlgorithm.ECDSA_P256, KeyAlgorithm.ECDSA_P384]:
            return f"-----BEGIN PUBLIC KEY-----\nMFkw...simulated...{algorithm.value}...\n-----END PUBLIC KEY-----"
        elif algorithm == KeyAlgorithm.ED25519:
            return f"-----BEGIN PUBLIC KEY-----\nMCow...simulated...ed25519...\n-----END PUBLIC KEY-----"
        return ""
        
    async def create_key_ring(self, name: str,
                             location: str = "global",
                             labels: Dict[str, str] = None) -> KeyRing:
        """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ÑĞ²ÑĞ·ĞºĞ¸ ĞºĞ»ÑÑ‡ĞµĞ¹"""
        ring = KeyRing(
            ring_id=f"ring_{uuid.uuid4().hex[:8]}",
            name=name,
            location=location,
            labels=labels or {}
        )
        
        self.key_rings[ring.ring_id] = ring
        return ring
        
    async def create_key(self, name: str,
                        key_ring_id: str,
                        key_type: KeyType,
                        algorithm: KeyAlgorithm,
                        usage: List[KeyUsage],
                        owner_id: str,
                        description: str = "",
                        labels: Dict[str, str] = None,
                        rotation_period_days: int = 365,
                        hsm_protected: bool = False,
                        is_exportable: bool = False) -> Optional[CryptoKey]:
        """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ ĞºĞ»ÑÑ‡Ğ°"""
        ring = self.key_rings.get(key_ring_id)
        if not ring:
            return None
            
        key = CryptoKey(
            key_id=f"key_{uuid.uuid4().hex[:12]}",
            name=name,
            key_type=key_type,
            algorithm=algorithm,
            usage=usage,
            state=KeyState.ENABLED,
            origin=KeyOrigin.HSM if hsm_protected else KeyOrigin.KMS,
            rotation_period_days=rotation_period_days,
            next_rotation=datetime.now() + timedelta(days=rotation_period_days),
            is_exportable=is_exportable,
            hsm_protected=hsm_protected,
            labels=labels or {},
            description=description,
            owner_id=owner_id
        )
        
        # Generate key material
        key.key_material_hash = self._generate_key_material(algorithm)
        
        # For asymmetric keys, generate public key
        if key_type == KeyType.ASYMMETRIC:
            key.public_key_pem = self._generate_public_key(algorithm)
            
        # Create initial version
        version = KeyVersion(
            version_id=f"ver_{uuid.uuid4().hex[:8]}",
            key_id=key.key_id,
            version_number=1,
            key_material_hash=key.key_material_hash,
            public_key_pem=key.public_key_pem,
            algorithm=algorithm,
            is_primary=True
        )
        
        ring.key_ids.append(key.key_id)
        self.keys[key.key_id] = key
        self.key_versions[key.key_id] = [version]
        
        # Audit log
        await self._log_audit("create_key", key.key_id, 1, owner_id)
        
        return key
        
    async def rotate_key(self, key_id: str, principal_id: str) -> Optional[KeyVersion]:
        """Ğ Ğ¾Ñ‚Ğ°Ñ†Ğ¸Ñ ĞºĞ»ÑÑ‡Ğ°"""
        key = self.keys.get(key_id)
        if not key or key.state != KeyState.ENABLED:
            return None
            
        # Check access
        if not await self._check_access(key_id, principal_id, "rotate"):
            return None
            
        # Mark current version as non-primary
        versions = self.key_versions.get(key_id, [])
        for v in versions:
            v.is_primary = False
            
        # Create new version
        new_version_num = key.current_version + 1
        
        new_version = KeyVersion(
            version_id=f"ver_{uuid.uuid4().hex[:8]}",
            key_id=key_id,
            version_number=new_version_num,
            key_material_hash=self._generate_key_material(key.algorithm),
            public_key_pem=self._generate_public_key(key.algorithm) if key.key_type == KeyType.ASYMMETRIC else "",
            algorithm=key.algorithm,
            is_primary=True
        )
        
        versions.append(new_version)
        
        key.current_version = new_version_num
        key.key_material_hash = new_version.key_material_hash
        key.public_key_pem = new_version.public_key_pem
        key.last_rotated = datetime.now()
        key.next_rotation = datetime.now() + timedelta(days=key.rotation_period_days)
        
        # Audit log
        await self._log_audit("rotate_key", key_id, new_version_num, principal_id)
        
        return new_version
        
    async def encrypt(self, key_id: str,
                     plaintext: str,
                     principal_id: str,
                     aad: str = "") -> Optional[str]:
        """Ğ¨Ğ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…"""
        key = self.keys.get(key_id)
        if not key or key.state != KeyState.ENABLED:
            return None
            
        # Check usage
        if KeyUsage.ENCRYPT_DECRYPT not in key.usage:
            return None
            
        # Check access
        if not await self._check_access(key_id, principal_id, "encrypt"):
            return None
            
        request = EncryptionRequest(
            request_id=f"enc_{uuid.uuid4().hex[:12]}",
            key_id=key_id,
            key_version=key.current_version,
            operation="encrypt",
            input_size_bytes=len(plaintext),
            additional_authenticated_data=aad
        )
        
        import time
        start_time = time.time()
        
        # Simulate encryption
        encoded = base64.b64encode(plaintext.encode()).decode()
        ciphertext = f"ENC[{key_id}:{key.current_version}:{encoded}]"
        
        request.output_size_bytes = len(ciphertext)
        request.processing_time_ms = (time.time() - start_time) * 1000
        request.success = True
        request.ciphertext_crc32c = hashlib.md5(ciphertext.encode()).hexdigest()[:8]
        
        key.operations_count += 1
        key.last_used = datetime.now()
        
        versions = self.key_versions.get(key_id, [])
        for v in versions:
            if v.version_number == key.current_version:
                v.operations_count += 1
                break
                
        self.encryption_requests.append(request)
        
        # Audit log
        await self._log_audit("encrypt", key_id, key.current_version, principal_id)
        
        return ciphertext
        
    async def decrypt(self, key_id: str,
                     ciphertext: str,
                     principal_id: str,
                     aad: str = "") -> Optional[str]:
        """Ğ”ĞµÑˆĞ¸Ñ„Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ´Ğ°Ğ½Ğ½Ñ‹Ñ…"""
        key = self.keys.get(key_id)
        if not key or key.state != KeyState.ENABLED:
            return None
            
        # Check usage
        if KeyUsage.ENCRYPT_DECRYPT not in key.usage:
            return None
            
        # Check access
        if not await self._check_access(key_id, principal_id, "decrypt"):
            return None
            
        request = EncryptionRequest(
            request_id=f"dec_{uuid.uuid4().hex[:12]}",
            key_id=key_id,
            operation="decrypt",
            input_size_bytes=len(ciphertext),
            additional_authenticated_data=aad
        )
        
        import time
        start_time = time.time()
        
        # Simulate decryption
        if ciphertext.startswith("ENC["):
            parts = ciphertext[4:-1].split(":", 2)
            if len(parts) == 3:
                request.key_version = int(parts[1])
                plaintext = base64.b64decode(parts[2]).decode()
                
                request.output_size_bytes = len(plaintext)
                request.processing_time_ms = (time.time() - start_time) * 1000
                request.success = True
                
                key.operations_count += 1
                key.last_used = datetime.now()
                
                self.encryption_requests.append(request)
                
                # Audit log
                await self._log_audit("decrypt", key_id, request.key_version, principal_id)
                
                return plaintext
                
        request.success = False
        request.error_message = "Invalid ciphertext format"
        self.encryption_requests.append(request)
        return None
        
    async def sign(self, key_id: str,
                  digest: str,
                  principal_id: str,
                  digest_algorithm: str = "sha256") -> Optional[str]:
        """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞ¸"""
        key = self.keys.get(key_id)
        if not key or key.state != KeyState.ENABLED:
            return None
            
        # Check key type and usage
        if key.key_type != KeyType.ASYMMETRIC or KeyUsage.SIGN_VERIFY not in key.usage:
            return None
            
        # Check access
        if not await self._check_access(key_id, principal_id, "sign"):
            return None
            
        request = SignatureRequest(
            request_id=f"sig_{uuid.uuid4().hex[:12]}",
            key_id=key_id,
            key_version=key.current_version,
            operation="sign",
            digest_algorithm=digest_algorithm,
            digest_crc32c=hashlib.md5(digest.encode()).hexdigest()[:8]
        )
        
        # Simulate signing
        signature_data = f"{key_id}:{key.current_version}:{digest}:{uuid.uuid4().hex}"
        signature = base64.b64encode(hashlib.sha256(signature_data.encode()).digest()).decode()
        
        request.signature = signature
        request.signature_crc32c = hashlib.md5(signature.encode()).hexdigest()[:8]
        request.success = True
        
        key.operations_count += 1
        key.last_used = datetime.now()
        
        self.signature_requests.append(request)
        
        # Audit log
        await self._log_audit("sign", key_id, key.current_version, principal_id)
        
        return signature
        
    async def verify(self, key_id: str,
                    digest: str,
                    signature: str,
                    principal_id: str,
                    digest_algorithm: str = "sha256") -> bool:
        """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ¿Ğ¾Ğ´Ğ¿Ğ¸ÑĞ¸"""
        key = self.keys.get(key_id)
        if not key or key.state != KeyState.ENABLED:
            return False
            
        # Check key type and usage
        if key.key_type != KeyType.ASYMMETRIC or KeyUsage.SIGN_VERIFY not in key.usage:
            return False
            
        # Check access
        if not await self._check_access(key_id, principal_id, "verify"):
            return False
            
        request = SignatureRequest(
            request_id=f"ver_{uuid.uuid4().hex[:12]}",
            key_id=key_id,
            key_version=key.current_version,
            operation="verify",
            digest_algorithm=digest_algorithm,
            signature=signature
        )
        
        # Simulate verification (always true for demo)
        request.success = True
        request.verified = True
        
        key.operations_count += 1
        key.last_used = datetime.now()
        
        self.signature_requests.append(request)
        
        # Audit log
        await self._log_audit("verify", key_id, key.current_version, principal_id)
        
        return True
        
    async def get_public_key(self, key_id: str, principal_id: str) -> Optional[str]:
        """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ğ¿ÑƒĞ±Ğ»Ğ¸Ñ‡Ğ½Ğ¾Ğ³Ğ¾ ĞºĞ»ÑÑ‡Ğ°"""
        key = self.keys.get(key_id)
        if not key or key.state != KeyState.ENABLED:
            return None
            
        if key.key_type != KeyType.ASYMMETRIC:
            return None
            
        # Audit log
        await self._log_audit("get_public_key", key_id, key.current_version, principal_id)
        
        return key.public_key_pem
        
    async def disable_key(self, key_id: str, principal_id: str) -> bool:
        """ĞÑ‚ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ ĞºĞ»ÑÑ‡Ğ°"""
        key = self.keys.get(key_id)
        if not key:
            return False
            
        # Check access
        if not await self._check_access(key_id, principal_id, "admin"):
            return False
            
        key.state = KeyState.DISABLED
        
        # Audit log
        await self._log_audit("disable_key", key_id, key.current_version, principal_id)
        
        return True
        
    async def enable_key(self, key_id: str, principal_id: str) -> bool:
        """Ğ’ĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ğµ ĞºĞ»ÑÑ‡Ğ°"""
        key = self.keys.get(key_id)
        if not key or key.state == KeyState.DESTROYED:
            return False
            
        # Check access
        if not await self._check_access(key_id, principal_id, "admin"):
            return False
            
        key.state = KeyState.ENABLED
        
        # Audit log
        await self._log_audit("enable_key", key_id, key.current_version, principal_id)
        
        return True
        
    async def schedule_key_destruction(self, key_id: str,
                                      principal_id: str,
                                      delay_days: int = 30) -> bool:
        """ĞŸĞ»Ğ°Ğ½Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ¸Ğµ ÑƒĞ½Ğ¸Ñ‡Ñ‚Ğ¾Ğ¶ĞµĞ½Ğ¸Ñ ĞºĞ»ÑÑ‡Ğ°"""
        key = self.keys.get(key_id)
        if not key:
            return False
            
        # Check access
        if not await self._check_access(key_id, principal_id, "admin"):
            return False
            
        key.state = KeyState.PENDING_DELETION
        
        # Mark all versions for destruction
        versions = self.key_versions.get(key_id, [])
        destroy_time = datetime.now() + timedelta(days=delay_days)
        for v in versions:
            v.state = KeyState.PENDING_DELETION
            v.destroy_time = destroy_time
            
        # Audit log
        await self._log_audit("schedule_destruction", key_id, key.current_version, principal_id)
        
        return True
        
    async def create_policy(self, name: str,
                           key_ids: List[str],
                           allowed_operations: List[str],
                           principals: List[str],
                           key_ring_ids: List[str] = None) -> KeyPolicy:
        """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ Ğ¿Ğ¾Ğ»Ğ¸Ñ‚Ğ¸ĞºĞ¸ Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°"""
        policy = KeyPolicy(
            policy_id=f"pol_{uuid.uuid4().hex[:8]}",
            name=name,
            key_ring_ids=key_ring_ids or [],
            key_ids=key_ids,
            allowed_operations=allowed_operations,
            principals=principals
        )
        
        self.policies[policy.policy_id] = policy
        return policy
        
    async def _check_access(self, key_id: str,
                           principal_id: str,
                           operation: str) -> bool:
        """ĞŸÑ€Ğ¾Ğ²ĞµÑ€ĞºĞ° Ğ´Ğ¾ÑÑ‚ÑƒĞ¿Ğ°"""
        for policy in self.policies.values():
            if not policy.is_enabled:
                continue
                
            # Check principal
            if principal_id not in policy.principals and "*" not in policy.principals:
                continue
                
            # Check key
            if policy.key_ids and key_id not in policy.key_ids and "*" not in policy.key_ids:
                continue
                
            # Check operation
            if operation not in policy.allowed_operations and "admin" not in policy.allowed_operations:
                continue
                
            # Check time validity
            now = datetime.now()
            if policy.valid_from and now < policy.valid_from:
                continue
            if policy.valid_until and now > policy.valid_until:
                continue
                
            return True
            
        return False
        
    async def create_hsm_cluster(self, name: str,
                                hsm_type: str = "cloud",
                                endpoint: str = "") -> HSMCluster:
        """Ğ¡Ğ¾Ğ·Ğ´Ğ°Ğ½Ğ¸Ğµ HSM ĞºĞ»Ğ°ÑÑ‚ĞµÑ€Ğ°"""
        cluster = HSMCluster(
            cluster_id=f"hsm_{uuid.uuid4().hex[:8]}",
            name=name,
            hsm_type=hsm_type,
            endpoint=endpoint
        )
        
        self.hsm_clusters[cluster.cluster_id] = cluster
        return cluster
        
    async def _log_audit(self, operation: str,
                        key_id: str,
                        key_version: int,
                        principal_id: str,
                        success: bool = True,
                        error_code: str = "",
                        details: Dict[str, Any] = None):
        """Ğ—Ğ°Ğ¿Ğ¸ÑÑŒ Ğ² Ğ°ÑƒĞ´Ğ¸Ñ‚"""
        entry = AuditLogEntry(
            log_id=f"log_{uuid.uuid4().hex[:12]}",
            operation=operation,
            key_id=key_id,
            key_version=key_version,
            principal_id=principal_id,
            success=success,
            error_code=error_code,
            details=details or {}
        )
        
        self.audit_logs.append(entry)
        
    def get_keys_needing_rotation(self) -> List[CryptoKey]:
        """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ĞºĞ»ÑÑ‡ĞµĞ¹, Ñ‚Ñ€ĞµĞ±ÑƒÑÑ‰Ğ¸Ñ… Ñ€Ğ¾Ñ‚Ğ°Ñ†Ğ¸Ğ¸"""
        result = []
        now = datetime.now()
        
        for key in self.keys.values():
            if key.state != KeyState.ENABLED:
                continue
            if key.next_rotation and key.next_rotation <= now:
                result.append(key)
                
        return result
        
    def get_statistics(self) -> Dict[str, Any]:
        """Ğ¡Ñ‚Ğ°Ñ‚Ğ¸ÑÑ‚Ğ¸ĞºĞ°"""
        total_keys = len(self.keys)
        enabled_keys = sum(1 for k in self.keys.values() if k.state == KeyState.ENABLED)
        
        # By type
        by_type = {}
        for key in self.keys.values():
            t = key.key_type.value
            by_type[t] = by_type.get(t, 0) + 1
            
        # By algorithm
        by_algorithm = {}
        for key in self.keys.values():
            a = key.algorithm.value
            by_algorithm[a] = by_algorithm.get(a, 0) + 1
            
        total_versions = sum(len(v) for v in self.key_versions.values())
        total_rings = len(self.key_rings)
        total_policies = len(self.policies)
        
        total_encrypt_ops = sum(1 for r in self.encryption_requests if r.operation == "encrypt")
        total_decrypt_ops = sum(1 for r in self.encryption_requests if r.operation == "decrypt")
        total_sign_ops = sum(1 for r in self.signature_requests if r.operation == "sign")
        total_verify_ops = sum(1 for r in self.signature_requests if r.operation == "verify")
        
        hsm_protected = sum(1 for k in self.keys.values() if k.hsm_protected)
        needing_rotation = len(self.get_keys_needing_rotation())
        
        return {
            "total_keys": total_keys,
            "enabled_keys": enabled_keys,
            "keys_by_type": by_type,
            "keys_by_algorithm": by_algorithm,
            "total_versions": total_versions,
            "total_key_rings": total_rings,
            "total_policies": total_policies,
            "total_encrypt_operations": total_encrypt_ops,
            "total_decrypt_operations": total_decrypt_ops,
            "total_sign_operations": total_sign_ops,
            "total_verify_operations": total_verify_ops,
            "hsm_protected_keys": hsm_protected,
            "keys_needing_rotation": needing_rotation
        }


# Demo
async def main():
    print("=" * 60)
    print("Server Init - Iteration 338: Key Management Service Platform")
    print("=" * 60)
    
    kms = KeyManagementService()
    print("âœ“ Key Management Service initialized")
    
    # Create Key Rings
    print("\nğŸ”— Creating Key Rings...")
    
    rings_data = [
        ("production-keys", "us-east-1", {"env": "production"}),
        ("development-keys", "us-west-2", {"env": "development"}),
        ("staging-keys", "eu-west-1", {"env": "staging"}),
        ("global-keys", "global", {"env": "global"})
    ]
    
    rings = []
    for name, location, labels in rings_data:
        ring = await kms.create_key_ring(name, location, labels)
        rings.append(ring)
        print(f"  ğŸ”— {name} ({location})")
        
    # Create Access Policies
    print("\nğŸ“œ Creating Access Policies...")
    
    policies_data = [
        ("Admin Full Access", ["*"], ["encrypt", "decrypt", "sign", "verify", "rotate", "admin"], ["admin", "security-team"]),
        ("Developer Encrypt", [], ["encrypt", "decrypt"], ["developers"]),
        ("Signing Service", [], ["sign", "verify"], ["signing-service"]),
        ("Read Public Keys", [], ["get_public_key", "verify"], ["*"])
    ]
    
    policies = []
    for name, key_ids, ops, principals in policies_data:
        policy = await kms.create_policy(name, key_ids, ops, principals)
        policies.append(policy)
        print(f"  ğŸ“œ {name}")
        
    # Create Cryptographic Keys
    print("\nğŸ”‘ Creating Cryptographic Keys...")
    
    keys_data = [
        ("prod-data-encryption", rings[0].ring_id, KeyType.SYMMETRIC, KeyAlgorithm.AES_256, [KeyUsage.ENCRYPT_DECRYPT], "admin", "Production data encryption key", 90, False),
        ("prod-signing-key", rings[0].ring_id, KeyType.ASYMMETRIC, KeyAlgorithm.RSA_4096, [KeyUsage.SIGN_VERIFY], "admin", "Production signing key", 365, True),
        ("staging-encryption", rings[2].ring_id, KeyType.SYMMETRIC, KeyAlgorithm.AES_256, [KeyUsage.ENCRYPT_DECRYPT], "admin", "Staging encryption key", 180, False),
        ("dev-test-key", rings[1].ring_id, KeyType.SYMMETRIC, KeyAlgorithm.AES_128, [KeyUsage.ENCRYPT_DECRYPT], "developers", "Development test key", 365, False),
        ("jwt-signing-key", rings[3].ring_id, KeyType.ASYMMETRIC, KeyAlgorithm.ECDSA_P256, [KeyUsage.SIGN_VERIFY], "security-team", "JWT signing key", 90, True),
        ("api-hmac-key", rings[0].ring_id, KeyType.HMAC, KeyAlgorithm.HMAC_SHA256, [KeyUsage.GENERATE_VERIFY_MAC], "admin", "API HMAC key", 90, False),
        ("document-signing", rings[0].ring_id, KeyType.ASYMMETRIC, KeyAlgorithm.RSA_2048, [KeyUsage.SIGN_VERIFY], "admin", "Document signing key", 365, True),
        ("backup-encryption", rings[0].ring_id, KeyType.SYMMETRIC, KeyAlgorithm.AES_256, [KeyUsage.ENCRYPT_DECRYPT, KeyUsage.WRAP_UNWRAP], "admin", "Backup encryption key", 365, True),
        ("ed25519-signing", rings[3].ring_id, KeyType.ASYMMETRIC, KeyAlgorithm.ED25519, [KeyUsage.SIGN_VERIFY], "security-team", "ED25519 signing key", 180, False),
        ("token-encryption", rings[0].ring_id, KeyType.SYMMETRIC, KeyAlgorithm.AES_256, [KeyUsage.ENCRYPT_DECRYPT], "admin", "Token encryption key", 30, False)
    ]
    
    keys = []
    for name, ring_id, ktype, algo, usage, owner, desc, rotation, hsm in keys_data:
        key = await kms.create_key(name, ring_id, ktype, algo, usage, owner, desc,
                                  rotation_period_days=rotation, hsm_protected=hsm)
        if key:
            keys.append(key)
            print(f"  ğŸ”‘ {name} ({algo.value})")
            
    # Create HSM Cluster
    print("\nğŸ”’ Creating HSM Cluster...")
    
    hsm_cluster = await kms.create_hsm_cluster(
        "production-hsm",
        "cloud",
        "hsm.cloud.example.com"
    )
    print(f"  ğŸ”’ {hsm_cluster.name} ({hsm_cluster.hsm_type})")
    
    # Simulate Encryption Operations
    print("\nğŸ” Performing Encryption Operations...")
    
    encryption_ops = 0
    decryption_ops = 0
    
    for i in range(15):
        key = random.choice([k for k in keys if KeyUsage.ENCRYPT_DECRYPT in k.usage])
        plaintext = f"Sensitive data #{i}: {uuid.uuid4().hex}"
        
        ciphertext = await kms.encrypt(key.key_id, plaintext, "admin")
        if ciphertext:
            encryption_ops += 1
            
            # Decrypt
            decrypted = await kms.decrypt(key.key_id, ciphertext, "admin")
            if decrypted:
                decryption_ops += 1
                
    print(f"  âœ“ Encrypted: {encryption_ops}, Decrypted: {decryption_ops}")
    
    # Simulate Signing Operations
    print("\nâœï¸ Performing Signing Operations...")
    
    sign_ops = 0
    verify_ops = 0
    
    for i in range(10):
        key = random.choice([k for k in keys if KeyUsage.SIGN_VERIFY in k.usage])
        digest = hashlib.sha256(f"Document #{i}".encode()).hexdigest()
        
        signature = await kms.sign(key.key_id, digest, "admin")
        if signature:
            sign_ops += 1
            
            # Verify
            verified = await kms.verify(key.key_id, digest, signature, "admin")
            if verified:
                verify_ops += 1
                
    print(f"  âœ“ Signed: {sign_ops}, Verified: {verify_ops}")
    
    # Rotate a Key
    print("\nğŸ”„ Rotating Keys...")
    
    rotated_keys = 0
    for key in keys[:3]:
        new_version = await kms.rotate_key(key.key_id, "admin")
        if new_version:
            rotated_keys += 1
            print(f"  ğŸ”„ {key.name} â†’ v{new_version.version_number}")
            
    # Keys table
    print("\nğŸ”‘ Cryptographic Keys:")
    
    print("\n  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”")
    print("  â”‚ Name                      â”‚ Type        â”‚ Algorithm     â”‚ Usage             â”‚ Version â”‚ HSM â”‚ State      â”‚ Operations â”‚ Next Rotation                                              â”‚")
    print("  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤")
    
    for key in keys:
        name = key.name[:25].ljust(25)
        ktype = key.key_type.value[:11].ljust(11)
        algo = key.algorithm.value[:13].ljust(13)
        usage = ", ".join(u.value[:8] for u in key.usage[:2])[:17].ljust(17)
        version = f"v{key.current_version}".ljust(7)
        hsm = "âœ“" if key.hsm_protected else "âœ—"
        hsm = hsm.ljust(3)
        state = key.state.value[:10].ljust(10)
        ops = str(key.operations_count).ljust(10)
        
        next_rot = key.next_rotation.strftime("%Y-%m-%d") if key.next_rotation else "N/A"
        next_rot = next_rot[:58].ljust(58)
        
        print(f"  â”‚ {name} â”‚ {ktype} â”‚ {algo} â”‚ {usage} â”‚ {version} â”‚ {hsm} â”‚ {state} â”‚ {ops} â”‚ {next_rot} â”‚")
        
    print("  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
    
    # Key Versions
    print("\nğŸ“‹ Key Versions:")
    
    print("\n  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”")
    print("  â”‚ Key Name                  â”‚ Version â”‚ Algorithm     â”‚ Primary â”‚ State      â”‚ Operations â”‚ Created                   â”‚ Status                                                                         â”‚")
    print("  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤")
    
    for key in keys:
        versions = kms.key_versions.get(key.key_id, [])
        for ver in versions:
            name = key.name[:25].ljust(25)
            version = f"v{ver.version_number}".ljust(7)
            algo = ver.algorithm.value[:13].ljust(13)
            primary = "âœ“" if ver.is_primary else "âœ—"
            primary = primary.ljust(7)
            state = ver.state.value[:10].ljust(10)
            ops = str(ver.operations_count).ljust(10)
            created = ver.created_at.strftime("%Y-%m-%d %H:%M:%S")[:25].ljust(25)
            
            status = "âœ“ Active" if ver.state == KeyState.ENABLED else f"â—‹ {ver.state.value}"
            status = status[:80].ljust(80)
            
            print(f"  â”‚ {name} â”‚ {version} â”‚ {algo} â”‚ {primary} â”‚ {state} â”‚ {ops} â”‚ {created} â”‚ {status} â”‚")
            
    print("  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
    
    # Key Rings
    print("\nğŸ”— Key Rings:")
    
    print("\n  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”")
    print("  â”‚ Name                      â”‚ Location     â”‚ Keys â”‚ Labels                                  â”‚ Created                           â”‚")
    print("  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤")
    
    for ring in rings:
        name = ring.name[:25].ljust(25)
        location = ring.location[:12].ljust(12)
        keys_count = str(len(ring.key_ids)).ljust(4)
        labels = ", ".join(f"{k}={v}" for k, v in list(ring.labels.items())[:2])[:39].ljust(39)
        created = ring.created_at.strftime("%Y-%m-%d %H:%M:%S")[:35].ljust(35)
        
        print(f"  â”‚ {name} â”‚ {location} â”‚ {keys_count} â”‚ {labels} â”‚ {created} â”‚")
        
    print("  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
    
    # Access Policies
    print("\nğŸ“œ Access Policies:")
    
    print("\n  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”")
    print("  â”‚ Name                      â”‚ Operations                         â”‚ Principals                    â”‚ Status                                                              â”‚")
    print("  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤")
    
    for policy in policies:
        name = policy.name[:25].ljust(25)
        ops = ", ".join(policy.allowed_operations[:3])[:34].ljust(34)
        principals = ", ".join(policy.principals[:3])[:29].ljust(29)
        status = "âœ“ Enabled" if policy.is_enabled else "â—‹ Disabled"
        status = status[:69].ljust(69)
        
        print(f"  â”‚ {name} â”‚ {ops} â”‚ {principals} â”‚ {status} â”‚")
        
    print("  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
    
    # Recent Audit Logs
    print("\nğŸ“‹ Recent Audit Logs:")
    
    print("\n  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”")
    print("  â”‚ Operation            â”‚ Key ID                 â”‚ Version â”‚ Principal           â”‚ Timestamp            â”‚ Status                                                                   â”‚")
    print("  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤")
    
    for log in kms.audit_logs[-15:]:
        operation = log.operation[:20].ljust(20)
        key_id = log.key_id[:22].ljust(22)
        version = f"v{log.key_version}".ljust(7)
        principal = log.principal_id[:19].ljust(19)
        timestamp = log.timestamp.strftime("%Y-%m-%d %H:%M:%S")[:20].ljust(20)
        
        status_icon = "âœ“" if log.success else "âœ—"
        status = f"{status_icon} {'Success' if log.success else log.error_code}"[:74].ljust(74)
        
        print(f"  â”‚ {operation} â”‚ {key_id} â”‚ {version} â”‚ {principal} â”‚ {timestamp} â”‚ {status} â”‚")
        
    print("  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
    
    # Statistics
    stats = kms.get_statistics()
    
    print("\nğŸ“Š Overall Statistics:")
    
    print(f"\n  Total Keys: {stats['total_keys']}")
    print(f"  Enabled Keys: {stats['enabled_keys']}")
    print(f"  Key Versions: {stats['total_versions']}")
    print(f"  Key Rings: {stats['total_key_rings']}")
    print(f"  Policies: {stats['total_policies']}")
    print(f"  HSM Protected: {stats['hsm_protected_keys']}")
    print(f"  Needing Rotation: {stats['keys_needing_rotation']}")
    
    print("\n  Operations:")
    print(f"    Encrypt: {stats['total_encrypt_operations']}")
    print(f"    Decrypt: {stats['total_decrypt_operations']}")
    print(f"    Sign: {stats['total_sign_operations']}")
    print(f"    Verify: {stats['total_verify_operations']}")
    
    print("\n  Keys by Type:")
    for ktype, count in stats['keys_by_type'].items():
        print(f"    {ktype}: {count}")
        
    print("\n  Keys by Algorithm:")
    for algo, count in stats['keys_by_algorithm'].items():
        print(f"    {algo}: {count}")
        
    # Dashboard
    print("\nâ”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”")
    print("â”‚                   Key Management Service Platform                  â”‚")
    print("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤")
    print(f"â”‚ Total Keys:                   {stats['total_keys']:>12}                      â”‚")
    print(f"â”‚ Enabled Keys:                 {stats['enabled_keys']:>12}                      â”‚")
    print(f"â”‚ Key Versions:                 {stats['total_versions']:>12}                      â”‚")
    print("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤")
    print(f"â”‚ Encrypt Operations:           {stats['total_encrypt_operations']:>12}                      â”‚")
    print(f"â”‚ Decrypt Operations:           {stats['total_decrypt_operations']:>12}                      â”‚")
    print(f"â”‚ Sign Operations:              {stats['total_sign_operations']:>12}                      â”‚")
    print(f"â”‚ Verify Operations:            {stats['total_verify_operations']:>12}                      â”‚")
    print("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
    
    print("\n" + "=" * 60)
    print("Key Management Service Platform initialized!")
    print("=" * 60)


if __name__ == "__main__":
    asyncio.run(main())
